#include <stdint.h>
#include <avr/io.h>
#include <util/twi.h>
#include <util/delay.h>
#include <avr/pgmspace.h>

#define F_CPU 16000000UL

#define vga 0
#define qvga 1
#define qqvga 2

#define yuv422 0
#define rgb565 1
#define bayerRGB 2

#define camAddr_WR 0x42
#define camAddr_RD 0x43

/* Registers */
#define REG_GAIN 0x00            /* Gain lower 8 bits (rest in vref) */
#define REG_BLUE 0x01            /* blue gain */
#define REG_RED 0x02             /* red gain */
#define REG_VREF 0x03            /* Pieces of GAIN, VSTART, VSTOP */
#define REG_COM1 0x04            /* Control 1 */
#define COM1_CCIR656 0x40        /* CCIR656 enable */

#define REG_BAVE 0x05            /* U/B Average level */
#define REG_GbAVE 0x06           /* Y/Gb Average level */
#define REG_AECHH 0x07           /* AEC MS 5 bits */
#define REG_RAVE 0x08            /* V/R Average level */
#define REG_COM2 0x09            /* Control 2 */
#define COM2_SSLEEP 0x10         /* Soft sleep mode */

#define REG_PID 0x0a             /* Product ID MSB */
#define REG_VER 0x0b             /* Product ID LSB */

#define REG_COM3 0x0c            /* Control 3 */
#define COM3_SWAP 0x40           /* Byte swap */
#define COM3_SCALEEN 0x08        /* Enable scaling */
#define COM3_DCWEN 0x04          /* Enable downsamp/crop/window */

#define REG_COM4 0x0d            /* Control 4 */
#define REG_COM5 0x0e            /* All "reserved" */
#define REG_COM6 0x0f            /* Control 6 */

#define REG_AECH 0x10            /* More bits of AEC value */

#define REG_CLKRC 0x11           /* Clock control */
#define CLK_EXT 0x40             /* Use external clock directly */
#define CLK_SCALE 0x3f           /* Mask for internal clock scale */

#define REG_COM7 0x12            /* Control 7 */
#define COM7_RESET 0x80          /* Register reset */
#define COM7_FMT_MASK 0x38
#define COM7_FMT_VGA 0x00
#define COM7_FMT_CIF 0x20        /* CIF format */
#define COM7_FMT_QVGA 0x10       /* QVGA format */
#define COM7_FMT_QCIF 0x08       /* QCIF format */
#define COM7_RGB 0x04            /* RGB format */
#define COM7_YUV 0x00            /* YUV */
#define COM7_BAYER 0x01          /* Bayer format */
#define COM7_PBAYER 0x05         /* Processed Bayer */

#define REG_COM8 0x13
#define COM8_FASTAEC 0x80
#define COM8_AECSTEP 0x40
#define COM8_BFILT 0x20
#define COM8_AGC 0x04
#define COM8_AWB 0x02
#define COM8_AEC 0x01

#define REG_COM9 0x14
#define REG_COM10 0x15
#define COM10_HSYNC 0x40
#define COM10_PCLK_HB 0x20
#define COM10_HREF_REV 0x08
#define COM10_VS_LEAD 0x04
#define COM10_VS_NEG 0x02
#define COM10_HS_NEG 0x01

#define REG_HSTART 0x17
#define REG_HSTOP 0x18
#define REG_VSTART 0x19
#define REG_VSTOP 0x1a
#define REG_PSHFT 0x1b

#define REG_MIDH 0x1c
#define REG_MIDL 0x1d
#define REG_MVFP 0x1e
#define MVFP_MIRROR 0x20
#define MVFP_FLIP 0x10

#define REG_AEW 0x24
#define REG_AEB 0x25
#define REG_VPT 0x26

#define REG_HSYST 0x30
#define REG_HSYEN 0x31

#define REG_HREF 0x32

#define REG_TSLB 0x3a
#define TSLB_YLAST 0x04

#define REG_COM11 0x3b
#define COM11_NIGHT 0x80
#define COM11_NMFR 0x60
#define COM11_HZAUTO 0x10
#define COM11_50HZ 0x08
#define COM11_EXP 0x02

#define REG_COM12 0x3c
#define COM12_HREF 0x80

#define REG_COM13 0x3d
#define COM13_GAMMA 0x80
#define COM13_UVSAT 0x40
#define COM13_UVSWAP 0x01

#define REG_COM14 0x3e
#define COM14_DCWEN 0x10

#define REG_EDGE 0x3f
#define REG_COM15 0x40
#define COM15_R10F0 0x00
#define COM15_R01FE 0x80
#define COM15_R00FF 0xc0
#define COM15_RGB565 0x10
#define COM15_RGB555 0x30

#define REG_COM16 0x41
#define COM16_AWBGAIN 0x08

#define REG_COM17 0x42
#define COM17_AECWIN 0xc0
#define COM17_CBAR 0x08

#define REG_CMATRIX_BASE 0x4f
#define CMATRIX_LEN 6
#define REG_CMATRIX_SIGN 0x58

#define REG_BRIGHT 0x55
#define REG_CONTRAS 0x56
#define REG_GFIX 0x69

#define REG_REG76 0x76
#define R76_BLKPCOR 0x80
#define R76_WHTPCOR 0x40

#define REG_RGB444 0x8c
#define R444_ENABLE 0x02
#define R444_RGBX 0x01

#define REG_HAECC1 0x9f
#define REG_HAECC2 0xa0

#define REG_BD50MAX 0xa5
#define REG_HAECC3 0xa6
#define REG_HAECC4 0xa7
#define REG_HAECC5 0xa8
#define REG_HAECC6 0xa9
#define REG_HAECC7 0xaa
#define REG_BD60MAX 0xab

#define MTX1 0x4f
#define MTX2 0x50
#define MTX3 0x51
#define MTX4 0x52
#define MTX5 0x53
#define MTX6 0x54
#define MTXS 0x58

#define AWBC7 0x59
#define AWBC8 0x5a
#define AWBC9 0x5b
#define AWBC10 0x5c
#define AWBC11 0x5d
#define AWBC12 0x5e

#define REG_GFI 0x69
#define GGAIN 0x6a
#define DBLV 0x6b

#define AWBCTR3 0x6c
#define AWBCTR2 0x6d
#define AWBCTR1 0x6e
#define AWBCTR0 0x6f

struct regval_list {
    uint8_t  reg_num;
    uint16_t value;
};
const struct regval_list qvga_ov7670[] PROGMEM = {
  { REG_COM14, 0x19 }, { 0x72, 0x11 }, { 0x73, 0xf1 },
  { REG_HSTART, 0x16 }, { REG_HSTOP, 0x04 }, { REG_HREF, 0xa4 },
  { REG_VSTART, 0x02 }, { REG_VSTOP, 0x7a }, { REG_VREF, 0x0a },
  { 0xff, 0xff } /* END MARKER */
};

const struct regval_list yuv422_ov7670[] PROGMEM = {
  { REG_COM7, 0x00 }, { REG_RGB444, 0 }, { REG_COM1, 0 },
  { REG_COM15, COM15_R00FF }, { REG_COM9, 0x6A },
  { 0x4f, 0x80 }, { 0x50, 0x80 }, { 0x51, 0 },
  { 0x52, 0x22 }, { 0x53, 0x5e }, { 0x54, 0x80 },
  { REG_COM13, COM13_UVSAT }, { 0xff, 0xff }
};

const struct regval_list ov7670_default_regs[] PROGMEM = {
  { REG_COM7, COM7_RESET }, { REG_TSLB, 0x04 }, { REG_COM7, 0 },
  { REG_HSTART, 0x13 }, { REG_HSTOP, 0x01 }, { REG_HREF, 0xb6 },
  { REG_VSTART, 0x02 }, { REG_VSTOP, 0x7a }, { REG_VREF, 0x0a },
  { REG_COM3, 0 }, { REG_COM14, 0 },
  { 0x70, 0x3a }, { 0x71, 0x35 }, { 0x72, 0x11 }, { 0x73, 0xf0 },
  { 0xa2, 1 }, { REG_COM10, 0x0 },
  { 0x7a, 0x20 }, { 0x7b, 0x10 }, { 0x7c, 0x1e }, { 0x7d, 0x35 },
  { 0x7e, 0x5a }, { 0x7f, 0x69 }, { 0x80, 0x76 }, { 0x81, 0x80 },
  { 0x82, 0x88 }, { 0x83, 0x8f }, { 0x84, 0x96 }, { 0x85, 0xa3 },
  { 0x86, 0xaf }, { 0x87, 0xc4 }, { 0x88, 0xd7 }, { 0x89, 0xe8 },
  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP },
  { REG_GAIN, 0 }, { REG_AECH, 0 }, { REG_COM4, 0x40 },
  { REG_COM9, 0x18 }, { REG_BD50MAX, 0x05 }, { REG_BD60MAX, 0x07 },
  { REG_AEW, 0x95 }, { REG_AEB, 0x33 }, { REG_VPT, 0xe3 },
  { REG_HAECC1, 0x78 }, { REG_HAECC2, 0x68 }, { 0xa1, 0x03 },
  { REG_HAECC3, 0xd8 }, { REG_HAECC4, 0xd8 },
  { REG_HAECC5, 0xf0 }, { REG_HAECC6, 0x90 }, { REG_HAECC7, 0x94 },
  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC },
  { 0x30, 0 }, { 0x31, 0 },
  { REG_COM5, 0x61 }, { REG_COM6, 0x4b }, { 0x16, 0x02 },
  { REG_MVFP, 0x07 }, { 0x21, 0x02 }, { 0x22, 0x91 },
  { 0x29, 0x07 }, { 0x33, 0x0b }, { 0x35, 0x0b }, { 0x37, 0x1d },
  { 0x38, 0x71 }, { 0x39, 0x2a }, { REG_COM12, 0x78 },
  { 0x4d, 0x40 }, { 0x4e, 0x20 }, { REG_GFIX, 0 },
  { 0x74, 0x10 }, { 0x8d, 0x4f }, { 0x8e, 0 }, { 0x8f, 0 },
  { 0x90, 0 }, { 0x91, 0 }, { 0x96, 0 }, { 0x9a, 0 },
  { 0xb0, 0x84 }, { 0xb1, 0x0c }, { 0xb2, 0x0e },
  { 0xb3, 0x82 }, { 0xb8, 0x0a },
  { 0x43, 0x0a }, { 0x44, 0xf0 }, { 0x45, 0x34 }, { 0x46, 0x58 },
  { 0x47, 0x28 }, { 0x48, 0x3a },
  { 0x59, 0x88 }, { 0x5a, 0x88 }, { 0x5b, 0x44 },
  { 0x5c, 0x67 }, { 0x5d, 0x49 }, { 0x5e, 0x0e },
  { 0x6c, 0x0a }, { 0x6d, 0x55 }, { 0x6e, 0x11 }, { 0x6f, 0x9e },
  { 0x6a, 0x40 }, { REG_BLUE, 0x40 }, { REG_RED, 0x60 },
  { REG_COM8, COM8_FASTAEC | COM8_AECSTEP | COM8_AGC | COM8_AEC | COM8_AWB },
  { 0x4f, 0x80 }, { 0x50, 0x80 }, { 0x51, 0 }, { 0x52, 0x22 },
  { 0x53, 0x5e }, { 0x54, 0x80 }, { 0x58, 0x9e },
  { REG_COM16, COM16_AWBGAIN }, { REG_EDGE, 0 },
  { 0x75, 0x05 }, { REG_REG76, 0xe1 }, { 0x4c, 0 },
  { 0x77, 0x01 }, { REG_COM13, 0x48 }, { 0x4b, 0x09 }, { 0xc9, 0x60 },
  { 0x56, 0x40 }, { 0x34, 0x11 },
  { REG_COM11, COM11_EXP | COM11_HZAUTO },
  { 0xa4, 0x82 }, { 0x96, 0 }, { 0x97, 0x30 }, { 0x98, 0x20 },
  { 0x99, 0x30 }, { 0x9a, 0x84 }, { 0x9b, 0x29 }, { 0x9c, 0x03 },
  { 0x9d, 0x4c }, { 0x9e, 0x3f }, { 0x78, 0x04 },
  { 0x79, 0x01 }, { 0xc8, 0xf0 }, { 0x79, 0x0f }, { 0xc8, 0x00 },
  { 0x79, 0x10 }, { 0xc8, 0x7e }, { 0x79, 0x0a }, { 0xc8, 0x80 },
  { 0x79, 0x0b }, { 0xc8, 0x01 }, { 0x79, 0x0c }, { 0xc8, 0x0f },
  { 0x79, 0x0d }, { 0xc8, 0x20 }, { 0x79, 0x09 }, { 0xc8, 0x80 },
  { 0x79, 0x02 }, { 0xc8, 0xc0 }, { 0x79, 0x03 }, { 0xc8, 0x40 },
  { 0x79, 0x05 }, { 0xc8, 0x30 }, { 0x79, 0x26 },
  { 0xff, 0xff }
};

void error_led(void) {
  DDRB |= 32;
  while (1) {
    PORTB ^= 32;
    _delay_ms(100);
  }
}

void twiStart(void) {
  TWCR = _BV(TWINT) | _BV(TWSTA) | _BV(TWEN);
  while (!(TWCR & (1 << TWINT)));
  if ((TWSR & 0xF8) != TW_START) error_led();
}

void twiWriteByte(uint8_t DATA, uint8_t type) {
  TWDR = DATA;
  TWCR = _BV(TWINT) | _BV(TWEN);
  while (!(TWCR & (1 << TWINT)));
  if ((TWSR & 0xF8) != type) error_led();
}

void twiAddr(uint8_t addr, uint8_t typeTWI) {
  TWDR = addr;
  TWCR = _BV(TWINT) | _BV(TWEN);
  while (!(TWCR & _BV(TWINT)));
  if ((TWSR & 0xF8) != typeTWI) error_led();
}

void writeReg(uint8_t reg, uint8_t dat) {
  twiStart();
  twiAddr(camAddr_WR, TW_MT_SLA_ACK);
  twiWriteByte(reg, TW_MT_DATA_ACK);
  twiWriteByte(dat, TW_MT_DATA_ACK);
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
  _delay_ms(1);
}

static uint8_t twiRd(uint8_t nack) {
  if (nack) {
    TWCR = _BV(TWINT) | _BV(TWEN);
    while (!(TWCR & _BV(TWINT)));
    if ((TWSR & 0xF8) != TW_MR_DATA_NACK) error_led();
    return TWDR;
  } else {
    TWCR = _BV(TWINT) | _BV(TWEN) | _BV(TWEA);
    while (!(TWCR & _BV(TWINT)));
    if ((TWSR & 0xF8) != TW_MR_DATA_ACK) error_led();
    return TWDR;
  }
}

uint8_t rdReg(uint8_t reg) {
  uint8_t dat;
  twiStart();
  twiAddr(camAddr_WR, TW_MT_SLA_ACK);
  twiWriteByte(reg, TW_MT_DATA_ACK);
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
  _delay_ms(1);

  twiStart();
  twiAddr(camAddr_RD, TW_MR_SLA_ACK);
  dat = twiRd(1);
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
  _delay_ms(1);
  return dat;
}

void wrSensorRegs8_8(const struct regval_list reglist[]) {
  uint8_t reg_addr = 0, reg_val = 0;
  const struct regval_list *next = reglist;
  while ((reg_addr != 0xff) | (reg_val != 0xff)) {
    reg_addr = pgm_read_byte(&next->reg_num);
    reg_val = pgm_read_byte(&next->value);
    writeReg(reg_addr, reg_val);
    next++;
  }
}

void setColor(void) {
  wrSensorRegs8_8(yuv422_ov7670);
}

void setResolution(void) {
  writeReg(REG_COM3, 4);
  wrSensorRegs8_8(qvga_ov7670);
}

void camInit(void) {
  writeReg(0x12, 0x80);
  _delay_ms(100);
  wrSensorRegs8_8(ov7670_default_regs);
  uint8_t temp = rdReg(REG_COM10);
  writeReg(REG_COM10, temp | COM10_PCLK_HB);
  writeReg(REG_TSLB, 0x0C);
  writeReg(REG_COM10, 32);
}

void arduinoUnoInut(void) {
  cli();
  DDRB |= (1 << 3);
  ASSR &= ~(_BV(EXCLK) | _BV(AS2));
  TCCR2A = (1 << COM2A0) | (1 << WGM21) | (1 << WGM20);
  TCCR2B = (1 << WGM22) | (1 << CS20);
  OCR2A = 0;

  DDRC &= ~15;
  DDRD &= ~240;

  DDRD &= ~(1 << 2);
  DDRB &= ~(1 << 4);
  _delay_ms(3000);

  TWSR &= ~3;
  TWBR = 72;
  UBRR0H = 0;
  UBRR0L = 1;
  UCSR0A |= 2;
  UCSR0B = (1 << RXEN0) | (1 << TXEN0);
  UCSR0C = 6;
}

void StringPgm(const char *str) {
  do {
    while (!(UCSR0A & (1 << UDRE0)));
    UDR0 = pgm_read_byte_near(str);
    while (!(UCSR0A & (1 << UDRE0)));
  } while (pgm_read_byte_near(++str));
}

static void captureImg(uint16_t wg, uint16_t hg) {
  uint16_t y, x;
  StringPgm(PSTR("*RDY*"));
  while (!(PIND & (1 << 2)));
  while (PIND & (1 << 2));

  y = hg;
  while (y--) {
    x = wg;
    while (x--) {
      while ((PINB & (1 << 4)));
      UDR0 = (PINC & 15) | (PIND & 240);
      while (!(UCSR0A & (1 << UDRE0)));

      while (!(PINB & (1 << 4)));
      while ((PINB & (1 << 4)));
      UDR0 = (PINC & 15) | (PIND & 240);
      while (!(UCSR0A & (1 << UDRE0)));

      while (!(PINB & (1 << 4)));
    }
  }
  _delay_ms(100);
}

void setup() {
  arduinoUnoInut();
  camInit();
  setResolution();
  setColor();
  writeReg(0x11, 13);
}

void loop() {
  captureImg(320, 240);
}
